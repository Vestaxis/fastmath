Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 fastmath (6.36-1) unstable; urgency=medium
 .
   * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
Author: Stephen Crowley <crow@zbox>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- fastmath-6.36.orig/Makefile
+++ fastmath-6.36/Makefile
@@ -2,13 +2,15 @@ OS:=$(shell uname -o)
 MAKEFILE_DIR:=$(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
 LDFLAGS := -shared -L../lib
 
-CFLAGS := -g -O3 -fPIC  -Iinclude
+CFLAGS := -g -O3 -fPIC  -Ifastmath
+
+prefix := $(DESTDIR)
 
 FULL_JAVA_HOME := /usr/lib/jvm/default-java
 PLATFORM := linux
-LIBS := -llapack -latlas -lblas -llapack_atlas -lmpfr -larb
+LIBS := -llapack -latlas -lblas -llapack_atlas -lmpfr -larb -lflint
 OUTLIBDIR := ../../src
-OUTLIB := $(MAKEFILE_DIR)/../../native/libfastmath.so 
+OUTLIB := libfastmath.so 
 LDFLAGS := $(LDFLAGS) \
 	-L/usr/lib/x86_64-linux-gnu \
 	-L/usr/lib/atlas-base \
@@ -31,3 +33,11 @@ $(OUTLIB): $(OBJS)
 clean:
 	-rm -rf *.o $(OUTLIB)
 
+install:
+	mkdir -p $(prefix)/usr/lib
+	cp -pv $(OUTLIB) $(prefix)/usr/lib
+	mkdir -p $(prefix)/usr/include
+	cp -pv fastmath.h fastmath_*.h $(prefix)/usr/include
+	mkdir -p $(prefix)/usr/include/fastmath
+	cp -pv fastmath/*.h $(prefix)/usr/include/fastmath
+
--- fastmath-6.36.orig/fastmath.h
+++ fastmath-6.36/fastmath.h
@@ -9,8 +9,8 @@
 #include "fastmath_BLAS1.h"
 #include "fastmath_Functions.h"
 #include "fastmath_Vector.h"
-#include "include/LambertW.h"
-#include "include/Vector.h"
+#include "fastmath/LambertW.h"
+#include "fastmath/Vector.h"
 #include <boost/multiprecision/mpfr.hpp>
 #include <arbpp.hpp>
 #include <flint.h>
--- /dev/null
+++ fastmath-6.36/fastmath/LambertW.h
@@ -0,0 +1,44 @@
+/*
+  Implementation of Lambert W function
+
+  Copyright (C) 2009 Darko Veberic, darko.veberic@ung.si
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _LambertW_h_
+#define _LambertW_h_
+
+#include <limits>
+
+
+template<int branch>
+double LambertWApproximation(const double x);
+
+template<int branch>
+double LambertW(const double x);
+
+inline
+double
+LambertW(const int branch, const double x)
+{
+  switch (branch) {
+  case -1: return LambertW<-1>(x);
+  case  0: return LambertW<0>(x);
+  default: return std::numeric_limits<double>::quiet_NaN();
+  }
+}
+
+
+#endif
--- /dev/null
+++ fastmath-6.36/fastmath/Makefile
@@ -0,0 +1,44 @@
+S:=$(shell uname -o)
+MAKEFILE_DIR:=$(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+BASE_DIR:=$(MAKEFILE_DIR)/../../..
+
+ifneq ($(OS),GNU/Linux)
+ FULL_JAVA_HOME := $(shell cygpath -u "$(JAVA_HOME)")
+ PLATFORM := win32
+ LIBS := -llapack -lstdc++
+else
+ FULL_JAVA_HOME := /usr/lib/jvm/default-java
+ PLATFORM := linux
+LIBS := -latlas -llapack -lstdc++
+endif
+
+
+CFLAGS := -I /usr/include -I $(FULL_JAVA_HOME)/include -I $(FULL_JAVA_HOME)/include/$(PLATFORM) -I../headers -g -O3 -march=i686
+LDFLAGS := -shared -Wl,-rpath=lib $(LIBS)
+
+LIBDIR := ..
+LIB := $(LIBDIR)/libfastmath.so
+
+NATIVE_CLASSES := fastmath.BLAS1 fastmath.BufferUtils fastmath.DoubleMatrix fastmath.Vector fastmath.Functions
+.PHONY: headers
+
+all: $(LIB)
+
+headers:
+	#mvn -f $(BASE_DIR)/pom.xml dependency:build-classpath
+	javah -force -v -jni -d $(BASE_DIR)/cpp/fastmath -classpath $(BASE_DIR)/target/classes:`cat $(BASE_DIR)/class.path` $(NATIVE_CLASSES)
+
+OBJS := fastmath.o Matrix.o Vector.o
+
+$(LIB): $(OBJS)
+	g++ $(LDFLAGS) -o $@ $(filter %.o,$^) 
+
+%.o: %.c
+	gcc -c -o $@ $< $(CFLAGS)
+
+%.o: %.cpp
+	g++ -c -o $@ $< $(CFLAGS)
+
+clean:
+	-rm -rf *.o $(LIB)
+
--- /dev/null
+++ fastmath-6.36/fastmath/Vector.h
@@ -0,0 +1,39 @@
+#ifndef VECTOR_H_
+#define VECTOR_H_
+
+#include <jni.h>
+
+class Vector
+{
+ public:
+  Vector( JNIEnv *jEnv,
+          jobject jObject );
+
+  void divide( Vector &x );
+  void multiply( Vector &x );
+  void add( Vector &x );
+  void exp( );
+  void add( double x );
+  void pow( double x );
+  void assign( double x );
+  double sum( );
+  inline int dim() { return size; };
+  inline double& operator[] (const int i)
+  {
+      return buffer[ offset + ( i * increment ) ];
+  };
+ protected:
+  double *buffer;
+  int offset;
+  int increment;
+  int size;
+
+ private:
+  static bool initialized;
+  static jfieldID bufferFieldId;
+  static jfieldID sizeFieldId;
+  static jmethodID getOffsetMethodId;
+  static jmethodID getIncrementMethodId;
+};
+
+#endif /*VECTOR_H_*/
--- /dev/null
+++ fastmath-6.36/fastmath/atlas_aux.h
@@ -0,0 +1,769 @@
+/*
+ *             Automatically Tuned Linear Algebra Software v3.6.0
+ *                    (C) Copyright 1999 R. Clint Whaley
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions, and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. The name of the ATLAS group or the names of its contributers may
+ *      not be used to endorse or promote products derived from this
+ *      software without specific written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ATLAS GROUP OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Header file for ATLAS's auxiliary routines
+ */
+#ifndef ATLAS_AUX_H
+#define ATLAS_AUX_H
+#include "atlas_misc.h"
+
+void ATL_xerbla(int p, char *rout, char *form, ...);
+int ATL_lcm(const int M, const int N);
+double ATL_walltime();
+double ATL_cputime();
+
+/*
+ * Auxiliary routines that come in all four types
+ */
+void ATL_sgeadd(const int M, const int N, const float alpha,
+                const float *A, const int lda, const float beta,
+                float *C, const int ldc);
+
+void ATL_sgemove(const int M, const int N, const float alpha,
+                 const float *A, const int lda, float *C, const int ldc);
+
+void ATL_sgecopy(const int M, const int N, const float *A, const int lda,
+                 float *C, const int ldc);
+
+void ATL_sgescal(const int M, const int N, const float beta,
+                 float *C, const int ldc);
+void ATL_strscal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const float alpha,
+    float *A, const int lda);
+void ATL_shescal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const float alpha,
+    float *A, const int lda);
+
+void ATL_sgezero(const int M, const int N, float *C, const int ldc);
+
+void ATL_szero(const int N, float *X, const int incX);
+void ATL_sset(const int N, const float alpha, float *X, const int incX);
+void ATL_sscal(const int N, const float alpha, float *X, const int incX);
+void ATL_scopy(const int N, const float *X, const int incX,
+               float *Y, const int incY);
+void ATL_scpsc(const int N, const float alpha, const float *X,
+               const int incX, float *Y, const int incY);
+void ATL_saxpy(const int N, const float alpha, const float *X,
+               const int incX, float *Y, const int incY);
+void ATL_saxpy_x1_y1(const int N, const float alpha, const float *X,
+                     const int incX, float *Y, const int incY);
+void ATL_saxpby(const int N, const float alpha, const float *X,
+                const int incX, const float beta, float *Y, const int incY);
+
+void ATL_sgeadd_a1_b1
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_a1_b1
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_a0_b1
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_a0_b1
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_aX_b1
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_aX_b1
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_a1_b0
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_a1_b0
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_a0_b0
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_a0_b0
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_aX_b0
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_aX_b0
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_a1_bX
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_a1_bX
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_a0_bX
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_a0_bX
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+void ATL_sgeadd_aX_bX
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, const float beta, float *C, const int ldc);
+void ATL_saxpby_aX_bX
+   (const int N, const float alpha, const float *X, const int incX,
+    const float beta, float *Y, const int incY);
+
+void ATL_sgemove_a1
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, float *C, const int ldc);
+void ATL_sgemove_a0
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, float *C, const int ldc);
+void ATL_sgemove_aX
+   (const int M, const int N, const float alpha, const float *A,
+    const int lda, float *C, const int ldc);
+
+void ATL_sgescal_b1
+   (const int M, const int N, const float beta, float *C, const int ldc);
+void ATL_sgescal_b0
+   (const int M, const int N, const float beta, float *C, const int ldc);
+void ATL_sgescal_bX
+   (const int M, const int N, const float beta, float *C, const int ldc);
+
+void ATL_dgeadd(const int M, const int N, const double alpha,
+                const double *A, const int lda, const double beta,
+                double *C, const int ldc);
+
+void ATL_dgemove(const int M, const int N, const double alpha,
+                 const double *A, const int lda, double *C, const int ldc);
+
+void ATL_dgecopy(const int M, const int N, const double *A, const int lda,
+                 double *C, const int ldc);
+
+void ATL_dgescal(const int M, const int N, const double beta,
+                 double *C, const int ldc);
+void ATL_dtrscal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const double alpha,
+    double *A, const int lda);
+void ATL_dhescal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const double alpha,
+    double *A, const int lda);
+
+void ATL_dgezero(const int M, const int N, double *C, const int ldc);
+
+void ATL_dzero(const int N, double *X, const int incX);
+void ATL_dset(const int N, const double alpha, double *X, const int incX);
+void ATL_dscal(const int N, const double alpha, double *X, const int incX);
+void ATL_dcopy(const int N, const double *X, const int incX,
+               double *Y, const int incY);
+void ATL_dcpsc(const int N, const double alpha, const double *X,
+               const int incX, double *Y, const int incY);
+void ATL_daxpy(const int N, const double alpha, const double *X,
+               const int incX, double *Y, const int incY);
+void ATL_daxpy_x1_y1(const int N, const double alpha, const double *X,
+                     const int incX, double *Y, const int incY);
+void ATL_daxpby(const int N, const double alpha, const double *X,
+                const int incX, const double beta, double *Y, const int incY);
+
+void ATL_dgeadd_a1_b1
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_a1_b1
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_a0_b1
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_a0_b1
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_aX_b1
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_aX_b1
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_a1_b0
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_a1_b0
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_a0_b0
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_a0_b0
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_aX_b0
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_aX_b0
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_a1_bX
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_a1_bX
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_a0_bX
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_a0_bX
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+void ATL_dgeadd_aX_bX
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, const double beta, double *C, const int ldc);
+void ATL_daxpby_aX_bX
+   (const int N, const double alpha, const double *X, const int incX,
+    const double beta, double *Y, const int incY);
+
+void ATL_dgemove_a1
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, double *C, const int ldc);
+void ATL_dgemove_a0
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, double *C, const int ldc);
+void ATL_dgemove_aX
+   (const int M, const int N, const double alpha, const double *A,
+    const int lda, double *C, const int ldc);
+
+void ATL_dgescal_b1
+   (const int M, const int N, const double beta, double *C, const int ldc);
+void ATL_dgescal_b0
+   (const int M, const int N, const double beta, double *C, const int ldc);
+void ATL_dgescal_bX
+   (const int M, const int N, const double beta, double *C, const int ldc);
+
+void ATL_cgeadd(const int M, const int N, const float *alpha,
+                const float *A, const int lda, const float *beta,
+                float *C, const int ldc);
+
+void ATL_cgemove(const int M, const int N, const float *alpha,
+                 const float *A, const int lda, float *C, const int ldc);
+
+void ATL_cgecopy(const int M, const int N, const float *A, const int lda,
+                 float *C, const int ldc);
+
+void ATL_cgescal(const int M, const int N, const float *beta,
+                 float *C, const int ldc);
+void ATL_ctrscal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const float *alpha,
+    float *A, const int lda);
+void ATL_chescal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const float alpha,
+    float *A, const int lda);
+
+void ATL_cgezero(const int M, const int N, float *C, const int ldc);
+
+void ATL_czero(const int N, float *X, const int incX);
+void ATL_cset(const int N, const float *alpha, float *X, const int incX);
+void ATL_cscal(const int N, const float *alpha, float *X, const int incX);
+void ATL_ccopy(const int N, const float *X, const int incX,
+               float *Y, const int incY);
+void ATL_ccpsc(const int N, const float *alpha, const float *X,
+               const int incX, float *Y, const int incY);
+void ATL_caxpy(const int N, const float *alpha, const float *X,
+               const int incX, float *Y, const int incY);
+void ATL_caxpy_x1_y1(const int N, const float *alpha, const float *X,
+                     const int incX, float *Y, const int incY);
+void ATL_caxpby(const int N, const float *alpha, const float *X,
+                const int incX, const float *beta, float *Y, const int incY);
+
+void ATL_cgeadd_a1_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a1_b1
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a0_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a0_b1
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aX_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aX_b1
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a1_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a1_b0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a0_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a0_b0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aX_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aX_b0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a1_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a1_bX
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a0_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a0_bX
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aX_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aX_bX
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+
+void ATL_cgemove_a1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, float *C, const int ldc);
+void ATL_cgemove_a0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, float *C, const int ldc);
+void ATL_cgemove_aX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, float *C, const int ldc);
+
+void ATL_cgescal_b1
+   (const int M, const int N, const float *beta, float *C, const int ldc);
+void ATL_cgescal_b0
+   (const int M, const int N, const float *beta, float *C, const int ldc);
+void ATL_cgescal_bX
+   (const int M, const int N, const float *beta, float *C, const int ldc);
+
+void ATL_zgeadd(const int M, const int N, const double *alpha,
+                const double *A, const int lda, const double *beta,
+                double *C, const int ldc);
+
+void ATL_zgemove(const int M, const int N, const double *alpha,
+                 const double *A, const int lda, double *C, const int ldc);
+
+void ATL_zgecopy(const int M, const int N, const double *A, const int lda,
+                 double *C, const int ldc);
+
+void ATL_zgescal(const int M, const int N, const double *beta,
+                 double *C, const int ldc);
+void ATL_ztrscal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const double *alpha,
+    double *A, const int lda);
+void ATL_zhescal
+   (const enum ATLAS_UPLO Uplo, const int M, const int N, const double alpha,
+    double *A, const int lda);
+
+void ATL_zgezero(const int M, const int N, double *C, const int ldc);
+
+void ATL_zzero(const int N, double *X, const int incX);
+void ATL_zset(const int N, const double *alpha, double *X, const int incX);
+void ATL_zscal(const int N, const double *alpha, double *X, const int incX);
+void ATL_zcopy(const int N, const double *X, const int incX,
+               double *Y, const int incY);
+void ATL_zcpsc(const int N, const double *alpha, const double *X,
+               const int incX, double *Y, const int incY);
+void ATL_zaxpy(const int N, const double *alpha, const double *X,
+               const int incX, double *Y, const int incY);
+void ATL_zaxpy_x1_y1(const int N, const double *alpha, const double *X,
+                     const int incX, double *Y, const int incY);
+void ATL_zaxpby(const int N, const double *alpha, const double *X,
+                const int incX, const double *beta, double *Y, const int incY);
+
+void ATL_zgeadd_a1_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a1_b1
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a0_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a0_b1
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aX_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aX_b1
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a1_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a1_b0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a0_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a0_b0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aX_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aX_b0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a1_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a1_bX
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a0_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a0_bX
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aX_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aX_bX
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+
+void ATL_zgemove_a1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, double *C, const int ldc);
+void ATL_zgemove_a0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, double *C, const int ldc);
+void ATL_zgemove_aX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, double *C, const int ldc);
+
+void ATL_zgescal_b1
+   (const int M, const int N, const double *beta, double *C, const int ldc);
+void ATL_zgescal_b0
+   (const int M, const int N, const double *beta, double *C, const int ldc);
+void ATL_zgescal_bX
+   (const int M, const int N, const double *beta, double *C, const int ldc);
+
+/*
+ * Specialized complex auxiliary routines
+ */
+
+void ATL_ccplxinvert
+   (const int N, float *X, const int incX, float *Y, const int incY);
+
+void ATL_cscalConj
+   (const int N, const float *alpha, float *X, const int incX);
+void ATL_ccopyConj
+   (const int N, const float *X, const int incX, float *Y, const int incY);
+void ATL_cmoveConj
+   (const int N, const float *alpha, const float *X, const int incX,
+    float *Y, const int incY);
+void ATL_caxpyConj
+   (const int N, const float *alpha, const float *X, const int incX,
+    float *Y, const int incY);
+void ATL_caxpyConj_x1_y1(const int N, const float *alpha, const float *X,
+                         const int incX, float *Y, const int incY);
+void ATL_caxpbyConj
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+
+void ATL_cgeaddConj_aXi0_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a1_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a0_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aX_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a1_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a0_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aX_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a1_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a0_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aX_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a1_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_a0_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aXi0_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_cgeaddConj_aX_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aXi0_b1
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_caxpby_aXi0_b1
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aXi0_b1
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aXi0_b0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_caxpby_aXi0_b0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aXi0_b0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aXi0_bXi0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_caxpby_aXi0_bXi0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aXi0_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aXi0_bX
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_caxpby_aXi0_bX
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aXi0_bX
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a1_bXi0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a1_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_a0_bXi0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_a0_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+void ATL_caxpby_aX_bXi0
+   (const int N, const float *alpha, const float *X, const int incX,
+    const float *beta, float *Y, const int incY);
+void ATL_cgeadd_aX_bXi0
+   (const int M, const int N, const float *alpha, const float *A,
+    const int lda, const float *beta, float *C, const int ldc);
+
+void ATL_cgemove_aXi0
+   (const int M, const int N, const float *alpha0, const float *A,
+    const int lda, float *C, const int ldc);
+
+void ATL_cgescal_bXi0
+   (const int M, const int N, const float *beta, float *C, const int ldc);
+
+void ATL_zcplxinvert
+   (const int N, double *X, const int incX, double *Y, const int incY);
+
+void ATL_zscalConj
+   (const int N, const double *alpha, double *X, const int incX);
+void ATL_zcopyConj
+   (const int N, const double *X, const int incX, double *Y, const int incY);
+void ATL_zmoveConj
+   (const int N, const double *alpha, const double *X, const int incX,
+    double *Y, const int incY);
+void ATL_zaxpyConj
+   (const int N, const double *alpha, const double *X, const int incX,
+    double *Y, const int incY);
+void ATL_zaxpyConj_x1_y1(const int N, const double *alpha, const double *X,
+                         const int incX, double *Y, const int incY);
+void ATL_zaxpbyConj
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+
+void ATL_zgeaddConj_aXi0_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a1_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a0_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aX_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a1_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a0_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aX_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a1_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a0_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aX_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a1_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_a0_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aXi0_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zgeaddConj_aX_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aXi0_b1
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zaxpby_aXi0_b1
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aXi0_b1
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aXi0_b0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zaxpby_aXi0_b0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aXi0_b0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aXi0_bXi0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zaxpby_aXi0_bXi0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aXi0_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aXi0_bX
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zaxpby_aXi0_bX
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aXi0_bX
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a1_bXi0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a1_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_a0_bXi0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_a0_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+void ATL_zaxpby_aX_bXi0
+   (const int N, const double *alpha, const double *X, const int incX,
+    const double *beta, double *Y, const int incY);
+void ATL_zgeadd_aX_bXi0
+   (const int M, const int N, const double *alpha, const double *A,
+    const int lda, const double *beta, double *C, const int ldc);
+
+void ATL_zgemove_aXi0
+   (const int M, const int N, const double *alpha0, const double *A,
+    const int lda, double *C, const int ldc);
+
+void ATL_zgescal_bXi0
+   (const int M, const int N, const double *beta, double *C, const int ldc);
+
+
+#if defined(ATL_USEPTHREADS) && !defined(ATL_flushcache)
+   #include "atlas_pthreads.h"
+   #define ATL_flushcache ATL_ptflushcache
+   #define ATL_PTCACHEMUL * ATL_NTHREADS
+#else
+   #define ATL_PTCACHEMUL
+#endif
+double ATL_flushcache(int size);
+
+#endif
--- /dev/null
+++ fastmath-6.36/fastmath/atlas_enum.h
@@ -0,0 +1,55 @@
+/*
+ *             Automatically Tuned Linear Algebra Software v3.6.0
+ *                    (C) Copyright 1997 R. Clint Whaley
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions, and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. The name of the ATLAS group or the names of its contributers may
+ *      not be used to endorse or promote products derived from this
+ *      software without specific written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ATLAS GROUP OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef ATLAS_ENUM_H
+   #define ATLAS_ENUM_H
+
+   #define CBLAS_ENUM_ONLY
+   #include "cblas.h"
+   #undef CBLAS_ENUM_ONLY
+
+   #define ATLAS_ORDER CBLAS_ORDER
+      #define AtlasRowMajor CblasRowMajor
+      #define AtlasColMajor CblasColMajor
+   #define ATLAS_TRANS CBLAS_TRANSPOSE
+      #define AtlasNoTrans CblasNoTrans
+      #define AtlasTrans CblasTrans
+      #define AtlasConjTrans CblasConjTrans
+   #define ATLAS_UPLO CBLAS_UPLO
+      #define AtlasUpper CblasUpper
+      #define AtlasLower CblasLower
+   #define ATLAS_DIAG CBLAS_DIAG
+      #define AtlasNonUnit CblasNonUnit
+      #define AtlasUnit CblasUnit
+   #define ATLAS_SIDE CBLAS_SIDE
+      #define AtlasLeft  CblasLeft
+      #define AtlasRight CblasRight
+
+#endif
+
--- /dev/null
+++ fastmath-6.36/fastmath/atlas_misc.h
@@ -0,0 +1,397 @@
+/*
+ *             Automatically Tuned Linear Algebra Software v3.6.0
+ *                    (C) Copyright 1997 R. Clint Whaley
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions, and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. The name of the ATLAS group or the names of its contributers may
+ *      not be used to endorse or promote products derived from this
+ *      software without specific written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ATLAS GROUP OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "atlas_enum.h"
+
+#ifndef ATLAS_MISC_H
+#define ATLAS_MISC_H
+#include "atlas_type.h"
+/*
+ * Some useful macro functions
+ */
+#ifndef time00
+   #if defined(WALL) || defined(PentiumCPS) || defined(ATL_USEPTHREADS)
+      #define time00 ATL_walltime
+   #else
+      #define time00 ATL_cputime
+   #endif
+#endif
+#define Mabs(x) ( (x) >= 0 ? (x) : -(x) )
+#define Mmax(x, y) ( (x) > (y) ? (x) : (y) )
+#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )
+#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )
+#define Mupcase(C) ( ((C) > 96 && (C) < 123) ? (C) & 0xDF : (C) )
+/*
+ * packed indexing functions (upper & lower)
+ */
+
+#define Mjoin(pre, nam) my_join(pre, nam)
+#define my_join(pre, nam) pre ## nam
+#define Mstr2(m) # m
+#define Mstr(m) Mstr2(m)
+
+#define ATL_assert(n_) \
+{ \
+   if (!(n_)) \
+   { \
+      ATL_xerbla(0, __FILE__, "assertion %s failed, line %d of file %s\n", \
+                 Mstr(n_), __LINE__, __FILE__); \
+   } \
+}
+
+#if defined(SREAL)
+   #define EPS 5.0e-7
+   #define TYPE float
+   #define PRE s
+   #define UPR s
+   #define PREU S
+   #define PATL ATL_s
+   #define PATU ATLU_s
+   #define UATL ATLU_s
+   #define CBLA cblas_s
+   #define PATLU ATL_s
+   #define ATL_rone   1.0f
+   #define ATL_rnone -1.0f
+   #define ATL_rzero   0.0f
+   #define ATL_typify(m_) Mjoin(m_,f)
+   #include "atlas_ssysinfo.h"
+#elif defined(DREAL)
+   #define EPS 1.0e-15
+   #define TYPE double
+   #define PRE d
+   #define UPR d
+   #define PREU D
+   #define PATL ATL_d
+   #define PATU ATLU_d
+   #define UATL ATLU_d
+   #define CBLA cblas_d
+   #define PATLU ATL_d
+   #define ATL_rone   1.0
+   #define ATL_rnone -1.0
+   #define ATL_rzero   0.0
+   #define ATL_typify(m_) m_
+   #include "atlas_dsysinfo.h"
+#elif defined (QREAL)
+   #define EPS 1.9259299443872358530559779425849273E-34L
+   #define TYPE long double
+   #define PRE q
+   #define UPR q
+   #define PREU Q
+   #define PATL ATL_q
+   #define PATU ATLU_q
+   #define CBLA cblas_q
+#elif defined(SCPLX)
+   #define EPS 5.0e-7
+   #define TYPE float
+   #define PRE c
+   #define UPR s
+   #define PREU C
+   #define PATL ATL_c
+   #define PATLU ATL_s
+   #define PATU ATLU_c
+   #define UATL ATLU_s
+   #define ATL_rone  1.0f
+   #define ATL_rnone -1.0f
+   #define ATL_rzero   0.0f
+   #define ATL_typify(m_) Mjoin(m_,f)
+   #define CBLA cblas_c
+   #include "atlas_csysinfo.h"
+#elif defined(DCPLX)
+   #define TYPE double
+   #define PRE z
+   #define UPR d
+   #define PREU Z
+   #define PATL ATL_z
+   #define PATLU ATL_d
+   #define PATU ATLU_z
+   #define UATL ATLU_d
+   #define EPS 1.0e-15
+   #define ATL_rone   1.0
+   #define ATL_rnone -1.0
+   #define ATL_rzero   0.0
+   #define ATL_typify(m_) m_
+   #define CBLA cblas_z
+   #include "atlas_zsysinfo.h"
+#endif
+
+#if defined (SREAL) || defined (DREAL) || defined (SCPLX) || defined (DCPLX)
+   #define ATL_sizeof Mjoin(PATL,size)
+   #define ATL_MulBySize Mjoin(PATL,MulBySize)
+   #define ATL_DivBySize Mjoin(PATL,DivBySize)
+#endif
+
+#if ( defined(SREAL) || defined(DREAL) || defined(QREAL) )
+   #define TREAL
+   #define SHIFT
+   #define SCALAR TYPE
+   #define SADD &
+   #define SVAL
+   #define SVVAL *
+   #define SCALAR_IS_ONE(M_scalar) ((M_scalar) == ATL_rone)
+   #define SCALAR_IS_NONE(M_scalar) ((M_scalar) == ATL_rnone)
+   #define SCALAR_IS_ZERO(M_scalar) ((M_scalar) == ATL_rzero)
+#elif defined(SCPLX) || defined(DCPLX)
+   #define TCPLX
+/*
+ * c = b*c + v;
+ */
+   #define CMULT2(v, a, b, tmp) \
+   { \
+      tmp = *(a) * *(b) - *(a+1) * *(b+1); \
+      *(b+1) = *(a) * *(b+1) + *(a+1) * *(b) + *(v+1); \
+      *(b) = tmp + *v; \
+   }
+   #define SHIFT << 1
+   #define SCALAR TYPE *
+   #define SADD
+   #define SVAL *
+   #define SVVAL
+   #define SCALAR_IS_ONE(M_scalar) \
+      ( (*(M_scalar) == ATL_rone) && ((M_scalar)[1] == ATL_rzero) )
+   #define SCALAR_IS_NONE(M_scalar) \
+      ( (*(M_scalar) == ATL_rnone) && ((M_scalar)[1] == ATL_rzero) )
+   #define SCALAR_IS_ZERO(M_scalar) \
+      ( (*(M_scalar) == ATL_rzero) && ((M_scalar)[1] == ATL_rzero) )
+#endif
+
+#if defined(ALPHA1)
+   #define ATL_MulByALPHA(x_) (x_)
+   #define NM _a1
+#elif defined (ALPHA0)
+   #define ATL_MulByALPHA(x_) ATL_rzero
+   #define NM _a0
+#elif defined (ALPHAN1)
+   #define ATL_MulByALPHA(x_) (-(x_))
+   #define NM _an1
+#elif defined (ALPHAXI0)
+   #define ATL_MulByALPHA(x_) (ralpha*(x_))
+   #define NM _aXi0
+#elif defined (ALPHA1C)
+   #define NM _a1c
+#elif defined (ALPHAN1C)
+   #define NM _an1c
+#elif defined (ALPHAXI0C)
+   #define NM _aXi0c
+#elif defined (ALPHAXC)
+   #define NM _aXc
+#elif defined (ALPHAX)
+   #define ATL_MulByALPHA(x_) (alpha*(x_))
+   #define NM _aX
+#endif
+
+#if defined(BETA1)
+   #define ATL_MulByBETA(x_) (x_)
+   #define MSTAT A[i] += v[i]
+   #define BNM _b1
+#elif defined(BETA1C)
+   #define BNM _b1c
+#elif defined(BETAN1)
+   #define ATL_MulByBETA(x_) (-(x_))
+   #define MSTAT A[i] = v[i] - A[i]
+   #define BNM _bn1
+#elif defined(BETAN1C)
+   #define BNM _bn1c
+#elif defined(BETA0)
+   #define ATL_MulByBETA(x_) ATL_rzero
+   #define MSTAT A[i] = v[i]
+   #define BNM _b0
+#elif defined (BETAXI0)
+   #define BNM _bXi0
+   #define ATL_MulByBETA(x_) (rbeta*(x_))
+#elif defined (BETAXI0C)
+   #define BNM _bXi0c
+#elif defined (BETAX)
+   #define ATL_MulByBETA(x_) (beta*(x_))
+   #define MSTAT A[i] = beta*A[i] + v[i]
+   #define BNM _bX
+#elif defined (BETAXC)
+   #define BNM _bXc
+#endif
+
+/* any alignment below this forces data copy in gemm */
+#ifndef ATL_MinMMAlign
+   #define ATL_MinMMAlign 16
+#endif
+#if (ATL_MinMMAlign == 1 || ATL_MinMMAlign == 0)
+   #define ATL_DataIsMinAligned(ptr) 1
+#elif (ATL_MinMMAlign == 2)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>1)<<1 == (size_t) (ptr) )
+#elif (ATL_MinMMAlign == 4)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>2)<<2 == (size_t) (ptr) )
+#elif (ATL_MinMMAlign == 8)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>3)<<3 == (size_t) (ptr) )
+#elif (ATL_MinMMAlign == 16)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>4)<<4 == (size_t) (ptr) )
+#elif (ATL_MinMMAlign == 32)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>5)<<5 == (size_t) (ptr) )
+#elif (ATL_MinMMAlign == 64)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>6)<<6 == (size_t) (ptr) )
+#elif (ATL_MinMMAlign == 128)
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))>>7)<<7 == (size_t) (ptr) )
+#else
+   #define ATL_DataIsMinAligned(ptr) \
+      ( (((size_t) (ptr))/ATL_MinMMAlign)*ATL_MinMMAlign == (size_t) (ptr) )
+#endif
+
+#define ATL_Cachelen 32
+#if (ATL_Cachelen == 4)
+   #define ATL_MulByCachelen(N_) ( (N_) << 2 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 2 )
+#elif (ATL_Cachelen == 8)
+   #define ATL_MulByCachelen(N_) ( (N_) << 3 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 3 )
+#elif (ATL_Cachelen == 16)
+   #define ATL_MulByCachelen(N_) ( (N_) << 4 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 4 )
+#elif (ATL_Cachelen == 32)
+   #define ATL_MulByCachelen(N_) ( (N_) << 5 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 5 )
+#elif (ATL_Cachelen == 64)
+   #define ATL_MulByCachelen(N_) ( (N_) << 6 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 6 )
+#elif (ATL_Cachelen == 128)
+   #define ATL_MulByCachelen(N_) ( (N_) << 7 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 7 )
+#elif (ATL_Cachelen == 256)
+   #define ATL_MulByCachelen(N_) ( (N_) << 8 )
+   #define ATL_DivByCachelen(N_) ( (N_) >> 8 )
+#else
+   #define ATL_MulByCachelen(N_) ( (N_) * ATL_Cachelen )
+   #define ATL_DivByCachelen(N_) ( (N_) / ATL_Cachelen )
+#endif
+
+#if (ATL_Cachelen < ATL_MinMMAlign)
+   Force a compilation error if our required alignment is at least the
+   minimum!!@^
+#endif
+
+#define ATL_AlignPtr(vp) \
+   (void*) (ATL_Cachelen + ATL_MulByCachelen(ATL_DivByCachelen((size_t) (vp))))
+
+#define ATL_FindPtrAdjust(vp, iadj_) \
+{ \
+   (iadj_) = ((size_t)(vp))-ATL_MulByCachelen(ATL_DivByCachelen((size_t)(vp)));\
+   if (iadj_) \
+   { \
+      if ( (iadj_) == ATL_MulBySize(ATL_DivBySize(iadj_)) ) \
+         (iadj_) = ATL_DivBySize(iadj_); \
+      else (iadj_) = 0; \
+   }\
+}
+#define ATL_FindMatAdjust(vp_, lda_, iadj_) \
+{ \
+   if (ATL_MulByCachelen(ATL_DivByCachelen(ATL_MulBySize(lda_))) \
+       == ATL_MulBySize(lda_)) \
+   { \
+      ATL_FindPtrAdjust(vp_, iadj_); \
+   } \
+   else (iadj_) = 0; \
+}
+
+/*
+ * Find N necessary for alignment.  Written as function for optimization,
+ * declared static to encourage inlining
+ */
+static int ATL_AlignOffset
+(const int N,       /* max return value */
+ const void *vp,    /* pointer to be aligned */
+ const int inc,     /* size of each elt, in bytes */
+ const int align)   /* required alignment, in bytes */
+{
+   const int p = align/inc;
+   const size_t k=(size_t)vp, j=k/inc;
+   int iret;
+   if (k == (j)*inc && p*inc == align)
+   {
+      iret = ((j+p-1) / p)*p - j;
+      if (iret <= N) return(iret);
+   }
+   return(N);
+}
+
+/*
+ * Gcc links in crap that MSVC++ and DVF can't handle if you use stdout
+ * or stderr, so use this beautiful kludge to avoid this problem -- RCW
+ */
+#ifdef GCCWIN
+
+#include <stdarg.h>
+static int WINFPRINTF(FILE *fpout, char *form, ...)
+{
+   int ierr=0;
+   va_list argptr;
+
+   va_start(argptr, form);
+   if (fpout == NULL) ierr = vprintf(form, argptr);
+   else ierr = vfprintf(fpout, form, argptr);
+   va_end(argptr);
+
+   return(ierr);
+}
+
+#ifdef stdout
+   #undef stdout
+#endif
+#ifdef stderr
+   #undef stderr
+#endif
+#ifdef assert
+   #undef assert
+#endif
+
+#define stdout NULL
+#define stderr NULL
+#define fprintf WINFPRINTF
+#define assert WINASSERT
+#define WINASSERT(n_) \
+{ \
+   if (!(n_)) \
+   { \
+      printf("assertion %s failed, line %d of file %s\n", \
+             Mstr(n_), __LINE__, __FILE__); \
+      exit(1); \
+   } \
+}
+
+#endif
+
+#include "atlas_aux.h"
+
+#endif
--- /dev/null
+++ fastmath-6.36/fastmath/atlas_type.h
@@ -0,0 +1,20 @@
+#ifndef ATLAS_TYPE_H
+#define ATLAS_TYPE_H
+
+#define ATL_isize 4
+#define ATL_ssize 4
+#define ATL_dsize 8
+#define ATL_csize 8
+#define ATL_zsize 16
+#define ATL_iMulBySize(N_) ((((N_)) << 2))
+#define ATL_sMulBySize(N_) ((((N_)) << 2))
+#define ATL_dMulBySize(N_) ((((N_)) << 3))
+#define ATL_cMulBySize(N_) ((((N_)) << 3))
+#define ATL_zMulBySize(N_) ((((N_)) << 4))
+#define ATL_iDivBySize(N_) ((N_) >> 2)
+#define ATL_sDivBySize(N_) ((N_) >> 2)
+#define ATL_cDivBySize(N_) ((N_) >> 3)
+#define ATL_dDivBySize(N_) ((N_) >> 3)
+#define ATL_zDivBySize(N_) ((N_) >> 4)
+
+#endif
--- /dev/null
+++ fastmath-6.36/fastmath/cblas.h
@@ -0,0 +1,578 @@
+#ifndef CBLAS_H
+#define CBLAS_H
+#include <stddef.h>
+
+/* Allow the use in C++ code.  */
+#ifdef __cplusplus
+extern "C" 
+{
+#endif
+
+/*
+ * Enumerated and derived types
+ */
+#define CBLAS_INDEX size_t  /* this may vary between platforms */
+
+enum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102};
+enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113};
+enum CBLAS_UPLO {CblasUpper=121, CblasLower=122};
+enum CBLAS_DIAG {CblasNonUnit=131, CblasUnit=132};
+enum CBLAS_SIDE {CblasLeft=141, CblasRight=142};
+
+/*
+ * ===========================================================================
+ * Prototypes for level 1 BLAS functions (complex are recast as routines)
+ * ===========================================================================
+ */
+float  cblas_sdsdot(const int N, const float alpha, const float *X,
+                    const int incX, const float *Y, const int incY);
+double cblas_dsdot(const int N, const float *X, const int incX, const float *Y,
+                   const int incY);
+float  cblas_sdot(const int N, const float  *X, const int incX,
+                  const float  *Y, const int incY);
+double cblas_ddot(const int N, const double *X, const int incX,
+                  const double *Y, const int incY);
+
+/*
+ * Functions having prefixes Z and C only
+ */
+void   cblas_cdotu_sub(const int N, const void *X, const int incX,
+                       const void *Y, const int incY, void *dotu);
+void   cblas_cdotc_sub(const int N, const void *X, const int incX,
+                       const void *Y, const int incY, void *dotc);
+
+void   cblas_zdotu_sub(const int N, const void *X, const int incX,
+                       const void *Y, const int incY, void *dotu);
+void   cblas_zdotc_sub(const int N, const void *X, const int incX,
+                       const void *Y, const int incY, void *dotc);
+
+
+/*
+ * Functions having prefixes S D SC DZ
+ */
+float  cblas_snrm2(const int N, const float *X, const int incX);
+float  cblas_sasum(const int N, const float *X, const int incX);
+
+double cblas_dnrm2(const int N, const double *X, const int incX);
+double cblas_dasum(const int N, const double *X, const int incX);
+
+float  cblas_scnrm2(const int N, const void *X, const int incX);
+float  cblas_scasum(const int N, const void *X, const int incX);
+
+double cblas_dznrm2(const int N, const void *X, const int incX);
+double cblas_dzasum(const int N, const void *X, const int incX);
+
+
+/*
+ * Functions having standard 4 prefixes (S D C Z)
+ */
+CBLAS_INDEX cblas_isamax(const int N, const float  *X, const int incX);
+CBLAS_INDEX cblas_idamax(const int N, const double *X, const int incX);
+CBLAS_INDEX cblas_icamax(const int N, const void   *X, const int incX);
+CBLAS_INDEX cblas_izamax(const int N, const void   *X, const int incX);
+
+/*
+ * ===========================================================================
+ * Prototypes for level 1 BLAS routines
+ * ===========================================================================
+ */
+
+/* 
+ * Routines with standard 4 prefixes (s, d, c, z)
+ */
+void cblas_sswap(const int N, float *X, const int incX, 
+                 float *Y, const int incY);
+void cblas_scopy(const int N, const float *X, const int incX, 
+                 float *Y, const int incY);
+void cblas_saxpy(const int N, const float alpha, const float *X,
+                 const int incX, float *Y, const int incY);
+
+void cblas_dswap(const int N, double *X, const int incX, 
+                 double *Y, const int incY);
+void cblas_dcopy(const int N, const double *X, const int incX, 
+                 double *Y, const int incY);
+void cblas_daxpy(const int N, const double alpha, const double *X,
+                 const int incX, double *Y, const int incY);
+
+void cblas_cswap(const int N, void *X, const int incX, 
+                 void *Y, const int incY);
+void cblas_ccopy(const int N, const void *X, const int incX, 
+                 void *Y, const int incY);
+void cblas_caxpy(const int N, const void *alpha, const void *X,
+                 const int incX, void *Y, const int incY);
+
+void cblas_zswap(const int N, void *X, const int incX, 
+                 void *Y, const int incY);
+void cblas_zcopy(const int N, const void *X, const int incX, 
+                 void *Y, const int incY);
+void cblas_zaxpy(const int N, const void *alpha, const void *X,
+                 const int incX, void *Y, const int incY);
+
+
+/* 
+ * Routines with S and D prefix only
+ */
+void cblas_srotg(float *a, float *b, float *c, float *s);
+void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P);
+void cblas_srot(const int N, float *X, const int incX,
+                float *Y, const int incY, const float c, const float s);
+void cblas_srotm(const int N, float *X, const int incX,
+                float *Y, const int incY, const float *P);
+
+void cblas_drotg(double *a, double *b, double *c, double *s);
+void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P);
+void cblas_drot(const int N, double *X, const int incX,
+                double *Y, const int incY, const double c, const double  s);
+void cblas_drotm(const int N, double *X, const int incX,
+                double *Y, const int incY, const double *P);
+
+
+/* 
+ * Routines with S D C Z CS and ZD prefixes
+ */
+void cblas_sscal(const int N, const float alpha, float *X, const int incX);
+void cblas_dscal(const int N, const double alpha, double *X, const int incX);
+void cblas_cscal(const int N, const void *alpha, void *X, const int incX);
+void cblas_zscal(const int N, const void *alpha, void *X, const int incX);
+void cblas_csscal(const int N, const float alpha, void *X, const int incX);
+void cblas_zdscal(const int N, const double alpha, void *X, const int incX);
+
+/*
+ * ===========================================================================
+ * Prototypes for level 2 BLAS
+ * ===========================================================================
+ */
+
+/* 
+ * Routines with standard 4 prefixes (S, D, C, Z)
+ */
+void cblas_sgemv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const float alpha, const float *A, const int lda,
+                 const float *X, const int incX, const float beta,
+                 float *Y, const int incY);
+void cblas_sgbmv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const int KL, const int KU, const float alpha,
+                 const float *A, const int lda, const float *X,
+                 const int incX, const float beta, float *Y, const int incY);
+void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const float *A, const int lda, 
+                 float *X, const int incX);
+void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const float *A, const int lda, 
+                 float *X, const int incX);
+void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const float *Ap, float *X, const int incX);
+void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const float *A, const int lda, float *X,
+                 const int incX);
+void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const float *A, const int lda,
+                 float *X, const int incX);
+void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const float *Ap, float *X, const int incX);
+
+void cblas_dgemv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const double alpha, const double *A, const int lda,
+                 const double *X, const int incX, const double beta,
+                 double *Y, const int incY);
+void cblas_dgbmv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const int KL, const int KU, const double alpha,
+                 const double *A, const int lda, const double *X,
+                 const int incX, const double beta, double *Y, const int incY);
+void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const double *A, const int lda, 
+                 double *X, const int incX);
+void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const double *A, const int lda, 
+                 double *X, const int incX);
+void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const double *Ap, double *X, const int incX);
+void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const double *A, const int lda, double *X,
+                 const int incX);
+void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const double *A, const int lda,
+                 double *X, const int incX);
+void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const double *Ap, double *X, const int incX);
+
+void cblas_cgemv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 const void *X, const int incX, const void *beta,
+                 void *Y, const int incY);
+void cblas_cgbmv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const int KL, const int KU, const void *alpha,
+                 const void *A, const int lda, const void *X,
+                 const int incX, const void *beta, void *Y, const int incY);
+void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *A, const int lda, 
+                 void *X, const int incX);
+void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const void *A, const int lda, 
+                 void *X, const int incX);
+void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *Ap, void *X, const int incX);
+void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *A, const int lda, void *X,
+                 const int incX);
+void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const void *A, const int lda,
+                 void *X, const int incX);
+void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *Ap, void *X, const int incX);
+
+void cblas_zgemv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 const void *X, const int incX, const void *beta,
+                 void *Y, const int incY);
+void cblas_zgbmv(const enum CBLAS_ORDER order,
+                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
+                 const int KL, const int KU, const void *alpha,
+                 const void *A, const int lda, const void *X,
+                 const int incX, const void *beta, void *Y, const int incY);
+void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *A, const int lda, 
+                 void *X, const int incX);
+void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const void *A, const int lda, 
+                 void *X, const int incX);
+void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *Ap, void *X, const int incX);
+void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *A, const int lda, void *X,
+                 const int incX);
+void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const int K, const void *A, const int lda,
+                 void *X, const int incX);
+void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
+                 const int N, const void *Ap, void *X, const int incX);
+
+
+/* 
+ * Routines with S and D prefixes only
+ */
+void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const float alpha, const float *A,
+                 const int lda, const float *X, const int incX,
+                 const float beta, float *Y, const int incY);
+void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const int K, const float alpha, const float *A,
+                 const int lda, const float *X, const int incX,
+                 const float beta, float *Y, const int incY);
+void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const float alpha, const float *Ap,
+                 const float *X, const int incX,
+                 const float beta, float *Y, const int incY);
+void cblas_sger(const enum CBLAS_ORDER order, const int M, const int N,
+                const float alpha, const float *X, const int incX,
+                const float *Y, const int incY, float *A, const int lda);
+void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const float alpha, const float *X,
+                const int incX, float *A, const int lda);
+void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const float alpha, const float *X,
+                const int incX, float *Ap);
+void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const float alpha, const float *X,
+                const int incX, const float *Y, const int incY, float *A,
+                const int lda);
+void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const float alpha, const float *X,
+                const int incX, const float *Y, const int incY, float *A);
+
+void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const double alpha, const double *A,
+                 const int lda, const double *X, const int incX,
+                 const double beta, double *Y, const int incY);
+void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const int K, const double alpha, const double *A,
+                 const int lda, const double *X, const int incX,
+                 const double beta, double *Y, const int incY);
+void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const double alpha, const double *Ap,
+                 const double *X, const int incX,
+                 const double beta, double *Y, const int incY);
+void cblas_dger(const enum CBLAS_ORDER order, const int M, const int N,
+                const double alpha, const double *X, const int incX,
+                const double *Y, const int incY, double *A, const int lda);
+void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const double alpha, const double *X,
+                const int incX, double *A, const int lda);
+void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const double alpha, const double *X,
+                const int incX, double *Ap);
+void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const double alpha, const double *X,
+                const int incX, const double *Y, const int incY, double *A,
+                const int lda);
+void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const double alpha, const double *X,
+                const int incX, const double *Y, const int incY, double *A);
+
+
+/* 
+ * Routines with C and Z prefixes only
+ */
+void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const void *alpha, const void *A,
+                 const int lda, const void *X, const int incX,
+                 const void *beta, void *Y, const int incY);
+void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const int K, const void *alpha, const void *A,
+                 const int lda, const void *X, const int incX,
+                 const void *beta, void *Y, const int incY);
+void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const void *alpha, const void *Ap,
+                 const void *X, const int incX,
+                 const void *beta, void *Y, const int incY);
+void cblas_cgeru(const enum CBLAS_ORDER order, const int M, const int N,
+                 const void *alpha, const void *X, const int incX,
+                 const void *Y, const int incY, void *A, const int lda);
+void cblas_cgerc(const enum CBLAS_ORDER order, const int M, const int N,
+                 const void *alpha, const void *X, const int incX,
+                 const void *Y, const int incY, void *A, const int lda);
+void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const float alpha, const void *X, const int incX,
+                void *A, const int lda);
+void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const float alpha, const void *X,
+                const int incX, void *A);
+void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
+                const void *alpha, const void *X, const int incX,
+                const void *Y, const int incY, void *A, const int lda);
+void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
+                const void *alpha, const void *X, const int incX,
+                const void *Y, const int incY, void *Ap);
+
+void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const void *alpha, const void *A,
+                 const int lda, const void *X, const int incX,
+                 const void *beta, void *Y, const int incY);
+void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const int K, const void *alpha, const void *A,
+                 const int lda, const void *X, const int incX,
+                 const void *beta, void *Y, const int incY);
+void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                 const int N, const void *alpha, const void *Ap,
+                 const void *X, const int incX,
+                 const void *beta, void *Y, const int incY);
+void cblas_zgeru(const enum CBLAS_ORDER order, const int M, const int N,
+                 const void *alpha, const void *X, const int incX,
+                 const void *Y, const int incY, void *A, const int lda);
+void cblas_zgerc(const enum CBLAS_ORDER order, const int M, const int N,
+                 const void *alpha, const void *X, const int incX,
+                 const void *Y, const int incY, void *A, const int lda);
+void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const double alpha, const void *X, const int incX,
+                void *A, const int lda);
+void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
+                const int N, const double alpha, const void *X,
+                const int incX, void *A);
+void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
+                const void *alpha, const void *X, const int incX,
+                const void *Y, const int incY, void *A, const int lda);
+void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
+                const void *alpha, const void *X, const int incX,
+                const void *Y, const int incY, void *Ap);
+
+/*
+ * ===========================================================================
+ * Prototypes for level 3 BLAS
+ * ===========================================================================
+ */
+
+/* 
+ * Routines with standard 4 prefixes (S, D, C, Z)
+ */
+void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
+                 const int K, const float alpha, const float *A,
+                 const int lda, const float *B, const int ldb,
+                 const float beta, float *C, const int ldc);
+void cblas_ssymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const int M, const int N,
+                 const float alpha, const float *A, const int lda,
+                 const float *B, const int ldb, const float beta,
+                 float *C, const int ldc);
+void cblas_ssyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                 const float alpha, const float *A, const int lda,
+                 const float beta, float *C, const int ldc);
+void cblas_ssyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                  const float alpha, const float *A, const int lda,
+                  const float *B, const int ldb, const float beta,
+                  float *C, const int ldc);
+void cblas_strmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const float alpha, const float *A, const int lda,
+                 float *B, const int ldb);
+void cblas_strsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const float alpha, const float *A, const int lda,
+                 float *B, const int ldb);
+
+void cblas_dgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
+                 const int K, const double alpha, const double *A,
+                 const int lda, const double *B, const int ldb,
+                 const double beta, double *C, const int ldc);
+void cblas_dsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const int M, const int N,
+                 const double alpha, const double *A, const int lda,
+                 const double *B, const int ldb, const double beta,
+                 double *C, const int ldc);
+void cblas_dsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                 const double alpha, const double *A, const int lda,
+                 const double beta, double *C, const int ldc);
+void cblas_dsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                  const double alpha, const double *A, const int lda,
+                  const double *B, const int ldb, const double beta,
+                  double *C, const int ldc);
+void cblas_dtrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const double alpha, const double *A, const int lda,
+                 double *B, const int ldb);
+void cblas_dtrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const double alpha, const double *A, const int lda,
+                 double *B, const int ldb);
+
+void cblas_cgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
+                 const int K, const void *alpha, const void *A,
+                 const int lda, const void *B, const int ldb,
+                 const void *beta, void *C, const int ldc);
+void cblas_csymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 const void *B, const int ldb, const void *beta,
+                 void *C, const int ldc);
+void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                 const void *alpha, const void *A, const int lda,
+                 const void *beta, void *C, const int ldc);
+void cblas_csyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                  const void *alpha, const void *A, const int lda,
+                  const void *B, const int ldb, const void *beta,
+                  void *C, const int ldc);
+void cblas_ctrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 void *B, const int ldb);
+void cblas_ctrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 void *B, const int ldb);
+
+void cblas_zgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
+                 const int K, const void *alpha, const void *A,
+                 const int lda, const void *B, const int ldb,
+                 const void *beta, void *C, const int ldc);
+void cblas_zsymm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 const void *B, const int ldb, const void *beta,
+                 void *C, const int ldc);
+void cblas_zsyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                 const void *alpha, const void *A, const int lda,
+                 const void *beta, void *C, const int ldc);
+void cblas_zsyr2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                  const void *alpha, const void *A, const int lda,
+                  const void *B, const int ldb, const void *beta,
+                  void *C, const int ldc);
+void cblas_ztrmm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 void *B, const int ldb);
+void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
+                 const enum CBLAS_DIAG Diag, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 void *B, const int ldb);
+
+
+/* 
+ * Routines with prefixes C and Z only
+ */
+void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 const void *B, const int ldb, const void *beta,
+                 void *C, const int ldc);
+void cblas_cherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                 const float alpha, const void *A, const int lda,
+                 const float beta, void *C, const int ldc);
+void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                  const void *alpha, const void *A, const int lda,
+                  const void *B, const int ldb, const float beta,
+                  void *C, const int ldc);
+
+void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
+                 const enum CBLAS_UPLO Uplo, const int M, const int N,
+                 const void *alpha, const void *A, const int lda,
+                 const void *B, const int ldb, const void *beta,
+                 void *C, const int ldc);
+void cblas_zherk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                 const double alpha, const void *A, const int lda,
+                 const double beta, void *C, const int ldc);
+void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+                  const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
+                  const void *alpha, const void *A, const int lda,
+                  const void *B, const int ldb, const double beta,
+                  void *C, const int ldc);
+
+void cblas_xerbla(int p, const char *rout, const char *form, ...);
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif
--- /dev/null
+++ fastmath-6.36/fastmath/clapack.h
@@ -0,0 +1,225 @@
+/*
+ *             Automatically Tuned Linear Algebra Software v3.6.0
+ *                    (C) Copyright 1999 R. Clint Whaley
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions, and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. The name of the ATLAS group or the names of its contributers may
+ *      not be used to endorse or promote products derived from this
+ *      software without specific written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ATLAS GROUP OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef CLAPACK_H
+
+#define CLAPACK_H
+#include "cblas.h"
+
+#ifndef ATLAS_ORDER
+#define ATLAS_ORDER CBLAS_ORDER
+#endif
+#ifndef ATLAS_UPLO
+#define ATLAS_UPLO CBLAS_UPLO
+#endif
+#ifndef ATLAS_DIAG
+#define ATLAS_DIAG CBLAS_DIAG
+#endif
+int clapack_sgesv( const enum CBLAS_ORDER Order,
+                   const int N,
+                   const int NRHS,
+                   float *A,
+                   const int lda,
+                   int *ipiv,
+                   float *B,
+                   const int ldb );
+int clapack_sgetrf( const enum CBLAS_ORDER Order, const int M, const int N, float *A, const int lda, int *ipiv );
+int clapack_sgetrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_TRANSPOSE Trans,
+                    const int N,
+                    const int NRHS,
+                    const float *A,
+                    const int lda,
+                    const int *ipiv,
+                    float *B,
+                    const int ldb );
+int clapack_sgetri( const enum CBLAS_ORDER Order, const int N, float *A, const int lda, const int *ipiv );
+int clapack_sposv( const enum ATLAS_ORDER Order,
+                   const enum ATLAS_UPLO Uplo,
+                   const int N,
+                   const int NRHS,
+                   float *A,
+                   const int lda,
+                   float *B,
+                   const int ldb );
+int clapack_spotrf( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, float *A, const int lda );
+int clapack_spotrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_UPLO Uplo,
+                    const int N,
+                    const int NRHS,
+                    const float *A,
+                    const int lda,
+                    float *B,
+                    const int ldb );
+int clapack_spotri( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, float *A, const int lda );
+int clapack_slauum( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, float *A, const int lda );
+int clapack_strtri( const enum ATLAS_ORDER Order,
+                    const enum ATLAS_UPLO Uplo,
+                    const enum ATLAS_DIAG Diag,
+                    const int N,
+                    float *A,
+                    const int lda );
+
+int clapack_dgesv( const enum CBLAS_ORDER Order,
+                   const int N,
+                   const int NRHS,
+                   double *A,
+                   const int lda,
+                   int *ipiv,
+                   double *B,
+                   const int ldb );
+int clapack_dgetrf( const enum CBLAS_ORDER Order, const int M, const int N, double *A, const int lda, int *ipiv );
+int clapack_dgetrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_TRANSPOSE Trans,
+                    const int N,
+                    const int NRHS,
+                    const double *A,
+                    const int lda,
+                    const int *ipiv,
+                    double *B,
+                    const int ldb );
+int clapack_dgetri( const enum CBLAS_ORDER Order, const int N, double *A, const int lda, const int *ipiv );
+int clapack_dposv( const enum ATLAS_ORDER Order,
+                   const enum ATLAS_UPLO Uplo,
+                   const int N,
+                   const int NRHS,
+                   double *A,
+                   const int lda,
+                   double *B,
+                   const int ldb );
+int clapack_dpotrf( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, double *A, const int lda );
+int clapack_dpotrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_UPLO Uplo,
+                    const int N,
+                    const int NRHS,
+                    const double *A,
+                    const int lda,
+                    double *B,
+                    const int ldb );
+int clapack_dpotri( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, double *A, const int lda );
+int clapack_dlauum( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, double *A, const int lda );
+int clapack_dtrtri( const enum ATLAS_ORDER Order,
+                    const enum ATLAS_UPLO Uplo,
+                    const enum ATLAS_DIAG Diag,
+                    const int N,
+                    double *A,
+                    const int lda );
+
+int clapack_cgesv( const enum CBLAS_ORDER Order,
+                   const int N,
+                   const int NRHS,
+                   void *A,
+                   const int lda,
+                   int *ipiv,
+                   void *B,
+                   const int ldb );
+int clapack_cgetrf( const enum CBLAS_ORDER Order, const int M, const int N, void *A, const int lda, int *ipiv );
+int clapack_cgetrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_TRANSPOSE Trans,
+                    const int N,
+                    const int NRHS,
+                    const void *A,
+                    const int lda,
+                    const int *ipiv,
+                    void *B,
+                    const int ldb );
+int clapack_cgetri( const enum CBLAS_ORDER Order, const int N, void *A, const int lda, const int *ipiv );
+int clapack_cposv( const enum ATLAS_ORDER Order,
+                   const enum ATLAS_UPLO Uplo,
+                   const int N,
+                   const int NRHS,
+                   void *A,
+                   const int lda,
+                   void *B,
+                   const int ldb );
+int clapack_cpotrf( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, void *A, const int lda );
+int clapack_cpotrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_UPLO Uplo,
+                    const int N,
+                    const int NRHS,
+                    const void *A,
+                    const int lda,
+                    void *B,
+                    const int ldb );
+int clapack_cpotri( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, void *A, const int lda );
+int clapack_clauum( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, void *A, const int lda );
+int clapack_ctrtri( const enum ATLAS_ORDER Order,
+                    const enum ATLAS_UPLO Uplo,
+                    const enum ATLAS_DIAG Diag,
+                    const int N,
+                    void *A,
+                    const int lda );
+
+int clapack_zgesv( const enum CBLAS_ORDER Order,
+                   const int N,
+                   const int NRHS,
+                   void *A,
+                   const int lda,
+                   int *ipiv,
+                   void *B,
+                   const int ldb );
+int clapack_zgetrf( const enum CBLAS_ORDER Order, const int M, const int N, void *A, const int lda, int *ipiv );
+int clapack_zgetrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_TRANSPOSE Trans,
+                    const int N,
+                    const int NRHS,
+                    const void *A,
+                    const int lda,
+                    const int *ipiv,
+                    void *B,
+                    const int ldb );
+int clapack_zgetri( const enum CBLAS_ORDER Order, const int N, void *A, const int lda, const int *ipiv );
+int clapack_zposv( const enum ATLAS_ORDER Order,
+                   const enum ATLAS_UPLO Uplo,
+                   const int N,
+                   const int NRHS,
+                   void *A,
+                   const int lda,
+                   void *B,
+                   const int ldb );
+int clapack_zpotrf( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, void *A, const int lda );
+int clapack_zpotrs( const enum CBLAS_ORDER Order,
+                    const enum CBLAS_UPLO Uplo,
+                    const int N,
+                    const int NRHS,
+                    const void *A,
+                    const int lda,
+                    void *B,
+                    const int ldb );
+int clapack_zpotri( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, void *A, const int lda );
+int clapack_zlauum( const enum ATLAS_ORDER Order, const enum ATLAS_UPLO Uplo, const int N, void *A, const int lda );
+int clapack_ztrtri( const enum ATLAS_ORDER Order,
+                    const enum ATLAS_UPLO Uplo,
+                    const enum ATLAS_DIAG Diag,
+                    const int N,
+                    void *A,
+                    const int lda );
+
+#endif
--- /dev/null
+++ fastmath-6.36/fastmath/lapack_defs.h
@@ -0,0 +1,137 @@
+#ifndef __LAPACK_DEFS_H
+#define __LAPACK_DEFS_H
+
+extern "C"
+{
+
+  double dnrm2_( jint *, double *, int * );
+
+  int drotg_( double *, double *, double *, double * );
+
+  int dgetrs_( const char &trans,
+               const int &n,
+               const int &nrhs,
+               const double a[],
+               const int &lda,
+               const int ipiv[],
+               double b[],
+               const int &ldb,
+               int &info );
+
+  double ddot_( const int &n, double dx[], const int &incx, double dy[], const int &incy );
+
+  int dsytrf_( const char &uplo,
+               const int &n,
+               double A[],
+               const int &lda,
+               int ipiv[],
+               double work[],
+               const int &lwork,
+               int &info );
+
+  int dsytri_( const char &uplo,
+               const int &n,
+               double A[],
+               const int &lda,
+               int ipiv[],
+               double work[],
+               const int &lwork,
+               int &info );
+
+  int dpotri_( const char &uplo, const int &n, double A[], const int &lda, int &info );
+
+  int dswap_( const int &n, double dx[], const int &incx, double dy[], const int &incy );
+
+  int dorgqr_( const int &m,
+               const int &n,
+               const int &k,
+               double a[],
+               const int &lda,
+               const double tau[],
+               double work[],
+               const int &lwork,
+               const int &info );
+
+  int dgeqp3_( const int &m,
+               const int &n,
+               double a[],
+               const int &lda,
+               int jpvt[],
+               double tau[],
+               double work[],
+               const int &lwork,
+               int &info );
+
+  void dsyev_( const char &jobz,
+               const char &uplo,
+               const int &n,
+               double A[],
+               const int &ldA,
+               double W[],
+               double work[],
+               const int &lwork,
+               int &info );
+
+  void dgelss_( const int &m,
+                const int &n,
+                const int &nrhs,
+                double A[],
+                const int &ldA,
+                double B[],
+                const int &ldB,
+                double S[],
+                const double &rcond,
+                int &rank,
+                double work[],
+                const int &lwork,
+                int &info );
+
+  int dlassq_( const int &n, const double *x, const int &incx, double &scale, double &sumsq );
+
+  void dgemm_( const char &transa,
+               const char &transb,
+               const int &m,
+               const int &n,
+               const int &k,
+               const double &alpha,
+               const double a[],
+               const int &lda,
+               const double b[],
+               const int &ldb,
+               const double &beta,
+               double c[],
+               const int &ldc );
+
+  int dgeev_( const char &jobvl,
+              const char &jobvr,
+              const int &n,
+              double a[],
+              const int &lda,
+              double wr[],
+              double wi[],
+              double vl[],
+              const int &ldvl,
+              double vr[],
+              const int &ldvr,
+              double work[],
+              const int &lwork,
+              int &info );
+
+  int zgeev_( const char &jobvl,
+              const char &jobvr,
+              const int &n,
+              double a[],
+              const int &lda,
+              double w[],
+              double vl[],
+              const int &ldvl,
+              double vr[],
+              const int &ldvr,
+              double work[],
+              const int &lwork,
+              double rwork[],
+              int &info );
+
+}
+
+#endif
--- fastmath-6.36.orig/jni.cpp
+++ fastmath-6.36/jni.cpp
@@ -4,9 +4,9 @@
 extern "C" {
 #endif
 
-#include "include/atlas_aux.h"
-#include "include/lapack_defs.h"
-#include "include/clapack.h"
+#include "fastmath/atlas_aux.h"
+#include "fastmath/lapack_defs.h"
+#include "fastmath/clapack.h"
 
 /*
  * Class:     fastmath_Functions
